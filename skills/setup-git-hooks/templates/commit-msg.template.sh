#!/bin/bash
# Commit-msg hook - Validates commit message format and conventions
# Generated by wrangler git-hooks framework
# Configuration: .wrangler/hooks-config.json

set -e

# =============================================================================
# Configuration (populated by setup-git-hooks skill)
# =============================================================================
COMMIT_MSG_PATTERN="{{COMMIT_MSG_PATTERN}}"
COMMIT_MSG_MIN_LENGTH="{{COMMIT_MSG_MIN_LENGTH}}"
COMMIT_MSG_MAX_LENGTH="{{COMMIT_MSG_MAX_LENGTH}}"
BYPASS_ENV_VAR="${WRANGLER_SKIP_HOOKS:-}"

# Commit message file passed as argument
COMMIT_MSG_FILE="$1"

# =============================================================================
# Logging helpers
# =============================================================================
log_info() {
    echo "[commit-msg] INFO: $1"
}

log_success() {
    echo "[commit-msg] OK: $1"
}

log_error() {
    echo "[commit-msg] ERROR: $1" >&2
}

log_warn() {
    echo "[commit-msg] WARN: $1"
}

# =============================================================================
# Bypass mechanism - allows users to skip hooks when needed
# =============================================================================
if [ -n "$BYPASS_ENV_VAR" ]; then
    log_warn "WRANGLER_SKIP_HOOKS is set - bypassing commit-msg validation"
    exit 0
fi

# =============================================================================
# Default configuration
# =============================================================================
# Default pattern: Conventional commits
if [ -z "$COMMIT_MSG_PATTERN" ] || [ "$COMMIT_MSG_PATTERN" = "{{COMMIT_MSG_PATTERN}}" ]; then
    COMMIT_MSG_PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-z0-9-]+\))?: .+"
fi

# Default min length
if [ -z "$COMMIT_MSG_MIN_LENGTH" ] || [ "$COMMIT_MSG_MIN_LENGTH" = "{{COMMIT_MSG_MIN_LENGTH}}" ]; then
    COMMIT_MSG_MIN_LENGTH=10
fi

# Default max length (for first line)
if [ -z "$COMMIT_MSG_MAX_LENGTH" ] || [ "$COMMIT_MSG_MAX_LENGTH" = "{{COMMIT_MSG_MAX_LENGTH}}" ]; then
    COMMIT_MSG_MAX_LENGTH=72
fi

# =============================================================================
# Read commit message
# =============================================================================
if [ ! -f "$COMMIT_MSG_FILE" ]; then
    log_error "Commit message file not found: $COMMIT_MSG_FILE"
    exit 1
fi

# Read the full commit message
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Get the first line (subject line)
FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)

# Remove comments (lines starting with #)
FIRST_LINE_CLEAN=$(echo "$FIRST_LINE" | grep -v "^#" || true)

# Skip if merge commit
if echo "$FIRST_LINE" | grep -q "^Merge"; then
    log_info "Merge commit detected - skipping validation"
    exit 0
fi

# Skip if empty (will be handled by git)
if [ -z "$FIRST_LINE_CLEAN" ]; then
    log_info "Empty commit message - git will handle this"
    exit 0
fi

# =============================================================================
# Validate message length
# =============================================================================
msg_length=${#FIRST_LINE_CLEAN}

if [ "$msg_length" -lt "$COMMIT_MSG_MIN_LENGTH" ]; then
    log_error "Commit message too short"
    log_error ""
    log_error "Your message: '$FIRST_LINE_CLEAN'"
    log_error "Length: $msg_length characters (minimum: $COMMIT_MSG_MIN_LENGTH)"
    log_error ""
    log_error "Please provide a more descriptive commit message."
    log_error ""
    log_error "Example: 'feat(auth): add OAuth2 login support'"
    exit 1
fi

if [ "$msg_length" -gt "$COMMIT_MSG_MAX_LENGTH" ]; then
    log_error "Commit message first line too long"
    log_error ""
    log_error "Your message: '$FIRST_LINE_CLEAN'"
    log_error "Length: $msg_length characters (maximum: $COMMIT_MSG_MAX_LENGTH)"
    log_error ""
    log_error "Keep the first line under $COMMIT_MSG_MAX_LENGTH characters."
    log_error "Use additional lines for details:"
    log_error ""
    log_error "Example:"
    log_error "  feat(auth): add OAuth2 login support"
    log_error ""
    log_error "  This implements OAuth2 authentication using the following providers:"
    log_error "  - Google"
    log_error "  - GitHub"
    log_error "  - Microsoft"
    exit 1
fi

# =============================================================================
# Validate message format
# =============================================================================
if ! echo "$FIRST_LINE_CLEAN" | grep -qE "$COMMIT_MSG_PATTERN"; then
    log_error "Commit message format invalid"
    log_error ""
    log_error "Your message: '$FIRST_LINE_CLEAN'"
    log_error ""
    log_error "This project uses Conventional Commits format:"
    log_error "  <type>(<scope>): <description>"
    log_error ""
    log_error "Valid types:"
    log_error "  feat     - A new feature"
    log_error "  fix      - A bug fix"
    log_error "  docs     - Documentation only changes"
    log_error "  style    - Formatting, missing semicolons, etc."
    log_error "  refactor - Code change that neither fixes a bug nor adds a feature"
    log_error "  perf     - Performance improvement"
    log_error "  test     - Adding or updating tests"
    log_error "  build    - Build system or external dependencies"
    log_error "  ci       - CI configuration changes"
    log_error "  chore    - Other changes that don't modify src or test files"
    log_error "  revert   - Reverts a previous commit"
    log_error ""
    log_error "Examples:"
    log_error "  feat(auth): add OAuth2 login support"
    log_error "  fix(api): handle null response from server"
    log_error "  docs: update installation instructions"
    log_error "  test(utils): add unit tests for date formatter"
    log_error ""
    log_error "To bypass (use sparingly):"
    log_error "  WRANGLER_SKIP_HOOKS=1 git commit -m 'message'"
    exit 1
fi

# =============================================================================
# Success
# =============================================================================
log_success "Commit message validated: $FIRST_LINE_CLEAN"
exit 0
